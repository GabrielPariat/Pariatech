(defun read-org-file (file)
  (with-open-file (stream file :direction :input)
    (loop for char = (read-char stream nil)
          while char
          collect char)))

(defun chars->symbol (lst) (intern (concatenate 'string lst)))

(defun parse-org-property-value (content)
  (labels ((f (content value)
             (let ((char (car content)))
               (if (and char (not (eq char #\NewLine)))
                   (f (cdr content) (cons char value))
                   (values value (cdr content))))))
    (multiple-value-bind (value rest) (f content nil)
      (values (string-trim '(#\Space #\Tab)
                           (concatenate 'string (reverse value)))
              rest))))

(defun parse-org-property (content)
  (labels ((f (content property)
             (let ((char (car content)))
               (cond ((eq char #\:)
                      (multiple-value-bind (value rest)
                          (parse-org-property-value (cdr content))
                        (values (cons (chars->symbol (reverse property))
                                      value)
                                rest)))
                     ((and char (not (eq char #\NewLine)))
                      (f (cdr content) (cons char property)))
                     (t (values (list (chars->symbol (reverse property)))
                                (cdr content)))))))
    (f content nil)))

(defun parse-org-title (content)
  (labels ((f (content lvl title)
             (let ((char (car content)))
               (cond ((and (not title) (eq char #\*))
                      (f (cdr content) (1+ lvl) title))
                     ((or (not char) (eq char #\NewLine))
                      (values `(,(chars->symbol (format nil "~a~a" 'H lvl))
                                ,(string-trim '(#\Space #\Tab)
                                              (concatenate 'string
                                                           (reverse title))))
                              (cdr content)))
                     (t (f (cdr content) lvl (cons char title)))))))
    (f content 0 nil)))

(defun parse-org-link (content)
  (labels ((f (content value)
             (let ((char (car content)))
               (cond ((or (not char)
                          (eq char #\]))
                      (values (concatenate 'string
                                           (reverse value))
                              (cddr content)))
                     ((eq char #\[) (f (cdr content) value))
                     (t (f (cdr content) (cons char value)))))))
    (multiple-value-bind (link rest)
        (f (cdr content) nil)
      (multiple-value-bind (value rest)
          (f rest nil)
        (values `(a :href ,link ,value)
                rest)))))

(defun chrs->string (chrs)
  (labels
      ((f (chrs text str)
         (let ((c (car chrs)))
           (cond ((not c) (if text
                           (cons (concatenate 'string (reverse text)) str)
                           str))
                 ((characterp c) (f (cdr chrs) (cons c text) str))
                 (t (f (cdr chrs)
                       nil
                       (cons c
                             (if text
                                 (cons (concatenate 'string (reverse text)) str)
                                 str))))))))
    (reverse (f chrs nil nil))))

(defun parse-org-paragraph (content)
  (labels ((f (content text)
             (let ((char (car content)))
               (cond ((or (not char)
                          (and (eq char #\NewLine)
                               (or (not (cadr content))
                                   (eq (cadr content) #\NewLine))))
                      (values `(P  ,@(chrs->string (reverse text)))
                              (cddr content)))
                     ((eq char #\[)
                      (multiple-value-bind (link rest)
                          (parse-org-link content)
                        (f (cdr rest) (cons link text))))
                     (t (f (cdr content) (cons char text)))))))
    (f content nil)))

(defun parse-org-header (content)
  (labels
      ((f (content header)
         (let ((c (car content))
               (nxtc (cadr content)))
           (cond ((and (eq c #\#) (eq nxtc #\+))
                  (multiple-value-bind (p rest)
                        (parse-org-property (cddr content))
                    (f rest (cons p header))))
                 (t (values `(header ,@(reverse header))
                            content))))))
    (f content nil)))

(defun parse-org-article (content)
  (labels ((f (content data)
               (cond ((eq (car content) #\*)
                      (multiple-value-bind (title rest)
                          (parse-org-title content)
                        (f rest (cons title data))))
                     ((eq (car content) #\NewLine) (f (cdr content) data))
                     ((car content)
                      (multiple-value-bind (paragraph rest)
                          (parse-org-paragraph content)
                        (f rest (cons paragraph data))))
                     (t data))))
      (cons 'article (reverse (f content nil)))))

(defun parse-org (content)
  (multiple-value-bind
        (header content)
      (parse-org-header content)
    (list header (parse-org-article content))))

(defun org-tokenizer (content)
  (labels
      ((f (content tokens rslt)
         (let ((c (car content))
               (nxt (cadr content))
               (token (car tokens)))
           (cond
             ((not c) (reverse rslt))
             ((and (eq c #\#) (eq nxt #\+))
              (f (cddr content)
                 (cons 'KEY (cons 'PROPERTY tokens))
                 (cons 'KEY (cons 'PROPERTY rslt))))
             ((eq token 'KEY)
              (if (eq c #\:)
                  (f (if (eq nxt #\Space) (cddr content) (cdr content))
                     (cons 'VALUE (cdr tokens))
                     (cons 'VALUE (cons 'END rslt)))
                  (f (cdr content) tokens (cons c rslt))))
             ((eq token 'VALUE)
              (if (eq c #\NewLine)
                  (f (cdr content) (cddr tokens) (cons 'END (cons 'END rslt)))
                  (f (cdr content) tokens (cons c rslt))))
             ((eq c #\*)
              (f (cdr content)
                 (cons 'LVL (cons 'TITLE tokens))
                 (cons c (cons 'LVL (cons 'TITLE rslt)))))
             ((eq token 'LVL)
              (if (eq c #\*)
                  (f (cdr content) tokens (cons c rslt))
                  (f (cdr content)
                     (cdr tokens)
                     (cons c rslt))))
             (t (f (cdr content) tokens rslt))))))
    (f content nil nil)))

(defun parse-org2 (chrs)
  (labels
      ((f (chrs data)
         (let ((c (car chrs))
               (nxtc (cadr chrs)))
           (cond
             ((not c) (reverse data))
             ((and (eq c #\#) (eq nxtc #\+))
              (list (f (cddr chrs) data)))
             (t (f (cdr chrs) (cons c data)))))))
    (f chrs nil)))

(defvar *org* (read-org-file "test.org"))
